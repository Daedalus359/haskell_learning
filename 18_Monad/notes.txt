Monad Typeclass Definition:

class Applicative m => Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  return :: a -> m a

initial impressions:
  1. return looks like 'pure' from Applicative. I assume it is the same
  2. (>>) seems like it could just discard its first argument. I don't see the point
  3. I'm assuming, as with Applicative, that the two monad structures in the arguments of (>>=) are combined monoidally

(*>) :: Applicative f => f a -> f b -> f b
(>>) :: Monad m => m a -> m b -> m b

note the difference between the following:
putStrLn <$> getLine
  --(<$>) :: Functor f => (a -> b) -> f a -> f b
  --the first argument to (<$>), putStrLn, is of type String -> IO ()
  --IO () thus fills the role of 'b' in the type signature of (<$>)
  --the second argument, getLine has type IO String
  --IO thus fills the role of f in the type signature of (<$>)
  --Then f b corresponds to the type IO (IO ())
join $ putStrLn $ getLine
  --join turns IO (IO ()) into just IO (), and it also does what we probably wanted

 
